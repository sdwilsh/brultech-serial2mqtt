"""
This type stub file was generated by pyright.
"""

import sys

from voluptuous.error import (
    BooleanInvalid,
    DirInvalid,
    EmailInvalid,
    FalseInvalid,
    FileInvalid,
    PathInvalid,
    TrueInvalid,
    UrlInvalid,
)
from voluptuous.schema_builder import message

if sys.version_info >= (3,):
    basestring = str
else: ...
USER_REGEX = ...
DOMAIN_REGEX = ...
__author__ = ...

def truth(f):  # -> (v: Unknown) -> Unknown:
    """Convenience decorator to convert truth functions into validators.

    >>> @truth
    ... def isdir(v):
    ...   return os.path.isdir(v)
    >>> validate = Schema(isdir)
    >>> validate('/')
    '/'
    >>> with raises(MultipleInvalid, 'not a valid value'):
    ...   validate('/notavaliddir')
    """
    ...

class Coerce:
    """Coerce a value to a type.

    If the type constructor throws a ValueError or TypeError, the value
    will be marked as Invalid.

    Default behavior:

        >>> validate = Schema(Coerce(int))
        >>> with raises(MultipleInvalid, 'expected int'):
        ...   validate(None)
        >>> with raises(MultipleInvalid, 'expected int'):
        ...   validate('foo')

    With custom message:

        >>> validate = Schema(Coerce(int, "moo"))
        >>> with raises(MultipleInvalid, 'moo'):
        ...   validate('foo')
    """

    def __init__(self, type, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

@message("value was not true", cls=TrueInvalid)
@truth
def IsTrue(v):
    """Assert that a value is true, in the Python sense.

    >>> validate = Schema(IsTrue())

    "In the Python sense" means that implicitly false values, such as empty
    lists, dictionaries, etc. are treated as "false":

    >>> with raises(MultipleInvalid, "value was not true"):
    ...   validate([])
    >>> validate([1])
    [1]
    >>> with raises(MultipleInvalid, "value was not true"):
    ...   validate(False)

    ...and so on.

    >>> try:
    ...  validate([])
    ... except MultipleInvalid as e:
    ...   assert isinstance(e.errors[0], TrueInvalid)
    """
    ...

@message("value was not false", cls=FalseInvalid)
def IsFalse(v):
    """Assert that a value is false, in the Python sense.

    (see :func:`IsTrue` for more detail)

    >>> validate = Schema(IsFalse())
    >>> validate([])
    []
    >>> with raises(MultipleInvalid, "value was not false"):
    ...   validate(True)

    >>> try:
    ...  validate(True)
    ... except MultipleInvalid as e:
    ...   assert isinstance(e.errors[0], FalseInvalid)
    """
    ...

@message("expected boolean", cls=BooleanInvalid)
def Boolean(v):  # -> bool:
    """Convert human-readable boolean values to a bool.

    Accepted values are 1, true, yes, on, enable, and their negatives.
    Non-string values are cast to bool.

    >>> validate = Schema(Boolean())
    >>> validate(True)
    True
    >>> validate("1")
    True
    >>> validate("0")
    False
    >>> with raises(MultipleInvalid, "expected boolean"):
    ...   validate('moo')
    >>> try:
    ...  validate('moo')
    ... except MultipleInvalid as e:
    ...   assert isinstance(e.errors[0], BooleanInvalid)
    """
    ...

class _WithSubValidators:
    """Base class for validators that use sub-validators.

    Special class to use as a parent class for validators using sub-validators.
    This class provides the `__voluptuous_compile__` method so the
    sub-validators are compiled by the parent `Schema`.
    """

    def __init__(self, *validators, **kwargs) -> None: ...
    def __voluptuous_compile__(self, schema): ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Any(_WithSubValidators):
    """Use the first validated value.

    :param msg: Message to deliver to user if validation fails.
    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.
    :returns: Return value of the first validator that passes.

    >>> validate = Schema(Any('true', 'false',
    ...                       All(Any(int, bool), Coerce(bool))))
    >>> validate('true')
    'true'
    >>> validate(1)
    True
    >>> with raises(MultipleInvalid, "not a valid value"):
    ...   validate('moo')

    msg argument is used

    >>> validate = Schema(Any(1, 2, 3, msg="Expected 1 2 or 3"))
    >>> validate(1)
    1
    >>> with raises(MultipleInvalid, "Expected 1 2 or 3"):
    ...   validate(4)
    """

    ...

Or = Any

class Union(_WithSubValidators):
    """Use the first validated value among those selected by discriminant.

    :param msg: Message to deliver to user if validation fails.
    :param discriminant(value, validators): Returns the filtered list of validators based on the value.
    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.
    :returns: Return value of the first validator that passes.

    >>> validate = Schema(Union({'type':'a', 'a_val':'1'},{'type':'b', 'b_val':'2'},
    ...                         discriminant=lambda val, alt: filter(
    ...                         lambda v : v['type'] == val['type'] , alt)))
    >>> validate({'type':'a', 'a_val':'1'}) == {'type':'a', 'a_val':'1'}
    True
    >>> with raises(MultipleInvalid, "not a valid value for dictionary value @ data['b_val']"):
    ...   validate({'type':'b', 'b_val':'5'})

    ```discriminant({'type':'b', 'a_val':'5'}, [{'type':'a', 'a_val':'1'},{'type':'b', 'b_val':'2'}])``` is invoked

    Without the discriminant, the exception would be "extra keys not allowed @ data['b_val']"
    """

    ...

Switch = Union

class All(_WithSubValidators):
    """Value must pass all validators.

    The output of each validator is passed as input to the next.

    :param msg: Message to deliver to user if validation fails.
    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.

    >>> validate = Schema(All('10', Coerce(int)))
    >>> validate('10')
    10
    """

    ...

And = All

class Match:
    """Value must be a string that matches the regular expression.

    >>> validate = Schema(Match(r'^0x[A-F0-9]+$'))
    >>> validate('0x123EF4')
    '0x123EF4'
    >>> with raises(MultipleInvalid, 'does not match regular expression ^0x[A-F0-9]+$'):
    ...   validate('123EF4')

    >>> with raises(MultipleInvalid, 'expected string or buffer'):
    ...   validate(123)

    Pattern may also be a compiled regular expression:

    >>> validate = Schema(Match(re.compile(r'0x[A-F0-9]+', re.I)))
    >>> validate('0x123ef4')
    '0x123ef4'
    """

    def __init__(self, pattern, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Replace:
    """Regex substitution.

    >>> validate = Schema(All(Replace('you', 'I'),
    ...                       Replace('hello', 'goodbye')))
    >>> validate('you say hello')
    'I say goodbye'
    """

    def __init__(self, pattern, substitution, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

@message("expected an email address", cls=EmailInvalid)
def Email(v):
    """Verify that the value is an email address or not.

    >>> s = Schema(Email())
    >>> with raises(MultipleInvalid, 'expected an email address'):
    ...   s("a.com")
    >>> with raises(MultipleInvalid, 'expected an email address'):
    ...   s("a@.com")
    >>> with raises(MultipleInvalid, 'expected an email address'):
    ...   s("a@.com")
    >>> s('t@x.com')
    't@x.com'
    """
    ...

@message("expected a fully qualified domain name URL", cls=UrlInvalid)
def FqdnUrl(v):
    """Verify that the value is a fully qualified domain name URL.

    >>> s = Schema(FqdnUrl())
    >>> with raises(MultipleInvalid, 'expected a fully qualified domain name URL'):
    ...   s("http://localhost/")
    >>> s('http://w3.org')
    'http://w3.org'
    """
    ...

@message("expected a URL", cls=UrlInvalid)
def Url(v):
    """Verify that the value is a URL.

    >>> s = Schema(Url())
    >>> with raises(MultipleInvalid, 'expected a URL'):
    ...   s(1)
    >>> s('http://w3.org')
    'http://w3.org'
    """
    ...

@message("Not a file", cls=FileInvalid)
@truth
def IsFile(v):  # -> bool:
    """Verify the file exists.

    >>> os.path.basename(IsFile()(__file__)).startswith('validators.py')
    True
    >>> with raises(FileInvalid, 'Not a file'):
    ...   IsFile()("random_filename_goes_here.py")
    >>> with raises(FileInvalid, 'Not a file'):
    ...   IsFile()(None)
    """
    ...

@message("Not a directory", cls=DirInvalid)
@truth
def IsDir(v):  # -> bool:
    """Verify the directory exists.

    >>> IsDir()('/')
    '/'
    >>> with raises(DirInvalid, 'Not a directory'):
    ...   IsDir()(None)
    """
    ...

@message("path does not exist", cls=PathInvalid)
@truth
def PathExists(v):  # -> bool:
    """Verify the path exists, regardless of its type.

    >>> os.path.basename(PathExists()(__file__)).startswith('validators.py')
    True
    >>> with raises(Invalid, 'path does not exist'):
    ...   PathExists()("random_filename_goes_here.py")
    >>> with raises(PathInvalid, 'Not a Path'):
    ...   PathExists()(None)
    """
    ...

def Maybe(validator, msg=...):  # -> Any:
    """Validate that the object matches given validator or is None.

    :raises Invalid: If the value does not match the given validator and is not
        None.

    >>> s = Schema(Maybe(int))
    >>> s(10)
    10
    >>> with raises(Invalid):
    ...  s("string")

    """
    ...

class Range:
    """Limit a value to a range.

    Either min or max may be omitted.
    Either min or max can be excluded from the range of accepted values.

    :raises Invalid: If the value is outside the range.

    >>> s = Schema(Range(min=1, max=10, min_included=False))
    >>> s(5)
    5
    >>> s(10)
    10
    >>> with raises(MultipleInvalid, 'value must be at most 10'):
    ...   s(20)
    >>> with raises(MultipleInvalid, 'value must be higher than 1'):
    ...   s(1)
    >>> with raises(MultipleInvalid, 'value must be lower than 10'):
    ...   Schema(Range(max=10, max_included=False))(20)
    """

    def __init__(
        self, min=..., max=..., min_included=..., max_included=..., msg=...
    ) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Clamp:
    """Clamp a value to a range.

    Either min or max may be omitted.

    >>> s = Schema(Clamp(min=0, max=1))
    >>> s(0.5)
    0.5
    >>> s(5)
    1
    >>> s(-1)
    0
    """

    def __init__(self, min=..., max=..., msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Length:
    """The length of a value must be in a certain range."""

    def __init__(self, min=..., max=..., msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Datetime:
    """Validate that the value matches the datetime format."""

    DEFAULT_FORMAT = ...
    def __init__(self, format=..., msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Date(Datetime):
    """Validate that the value matches the date format."""

    DEFAULT_FORMAT = ...
    def __call__(self, v): ...
    def __repr__(self): ...

class In:
    """Validate that a value is in a collection."""

    def __init__(self, container, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class NotIn:
    """Validate that a value is not in a collection."""

    def __init__(self, container, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Contains:
    """Validate that the given schema element is in the sequence being validated.

    >>> s = Contains(1)
    >>> s([3, 2, 1])
    [3, 2, 1]
    >>> with raises(ContainsInvalid, 'value is not allowed'):
    ...   s([3, 2])
    """

    def __init__(self, item, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class ExactSequence:
    """Matches each element in a sequence against the corresponding element in
    the validators.

    :param msg: Message to deliver to user if validation fails.
    :param kwargs: All other keyword arguments are passed to the sub-schema
        constructors.

    >>> from voluptuous import Schema, ExactSequence
    >>> validate = Schema(ExactSequence([str, int, list, list]))
    >>> validate(['hourly_report', 10, [], []])
    ['hourly_report', 10, [], []]
    >>> validate(('hourly_report', 10, [], []))
    ('hourly_report', 10, [], [])
    """

    def __init__(self, validators, **kwargs) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Unique:
    """Ensure an iterable does not contain duplicate items.

    Only iterables convertable to a set are supported (native types and
    objects with correct __eq__).

    JSON does not support set, so they need to be presented as arrays.
    Unique allows ensuring that such array does not contain dupes.

    >>> s = Schema(Unique())
    >>> s([])
    []
    >>> s([1, 2])
    [1, 2]
    >>> with raises(Invalid, 'contains duplicate items: [1]'):
    ...   s([1, 1, 2])
    >>> with raises(Invalid, "contains duplicate items: ['one']"):
    ...   s(['one', 'two', 'one'])
    >>> with raises(Invalid, regex="^contains unhashable elements: "):
    ...   s([set([1, 2]), set([3, 4])])
    >>> s('abc')
    'abc'
    >>> with raises(Invalid, regex="^contains duplicate items: "):
    ...   s('aabbc')
    """

    def __init__(self, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Equal:
    """Ensure that value matches target.

    >>> s = Schema(Equal(1))
    >>> s(1)
    1
    >>> with raises(Invalid):
    ...    s(2)

    Validators are not supported, match must be exact:

    >>> s = Schema(Equal(str))
    >>> with raises(Invalid):
    ...     s('foo')
    """

    def __init__(self, target, msg=...) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Unordered:
    """Ensures sequence contains values in unspecified order.

    >>> s = Schema(Unordered([2, 1]))
    >>> s([2, 1])
    [2, 1]
    >>> s([1, 2])
    [1, 2]
    >>> s = Schema(Unordered([str, int]))
    >>> s(['foo', 1])
    ['foo', 1]
    >>> s([1, 'foo'])
    [1, 'foo']
    """

    def __init__(self, validators, msg=..., **kwargs) -> None: ...
    def __call__(self, v): ...
    def __repr__(self): ...

class Number:
    """
    Verify the number of digits that are present in the number(Precision),
    and the decimal places(Scale).

    :raises Invalid: If the value does not match the provided Precision and Scale.

    >>> schema = Schema(Number(precision=6, scale=2))
    >>> schema('1234.01')
    '1234.01'
    >>> schema = Schema(Number(precision=6, scale=2, yield_decimal=True))
    >>> schema('1234.01')
    Decimal('1234.01')
    """

    def __init__(
        self, precision=..., scale=..., msg=..., yield_decimal=...
    ) -> None: ...
    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
        ...
    def __repr__(self): ...

class SomeOf(_WithSubValidators):
    """Value must pass at least some validations, determined by the given parameter.
    Optionally, number of passed validations can be capped.

    The output of each validator is passed as input to the next.

    :param min_valid: Minimum number of valid schemas.
    :param validators: List of schemas or validators to match input against.
    :param max_valid: Maximum number of valid schemas.
    :param msg: Message to deliver to user if validation fails.
    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.

    :raises NotEnoughValid: If the minimum number of validations isn't met.
    :raises TooManyValid: If the maximum number of validations is exceeded.

    >>> validate = Schema(SomeOf(min_valid=2, validators=[Range(1, 5), Any(float, int), 6.6]))
    >>> validate(6.6)
    6.6
    >>> validate(3)
    3
    >>> with raises(MultipleInvalid, 'value must be at most 5, not a valid value'):
    ...     validate(6.2)
    """

    def __init__(self, validators, min_valid=..., max_valid=..., **kwargs) -> None: ...
    def __repr__(self): ...
