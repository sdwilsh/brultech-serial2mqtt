"""
This type stub file was generated by pyright.
"""

import re
from collections.abc import Callable, Hashable
from datetime import date as date_sys
from datetime import datetime as datetime_sys
from datetime import time as time_sys
from datetime import timedelta
from enum import Enum
from typing import Any

import voluptuous as vol
from homeassistant.helpers import template as template_helper

"""Helpers for config validation using voluptuous."""
TIME_PERIOD_ERROR = ...
byte = ...
small_float = ...
positive_int = ...
positive_float = ...
latitude = ...
longitude = ...
gps = ...
sun_event = ...
port = ...
T = ...

def path(value: Any) -> str:
    """Validate it's a safe path."""
    ...

def has_at_least_one_key(*keys: Any) -> Callable[[dict], dict]:
    """Validate that at least one key exists."""
    ...

def has_at_most_one_key(*keys: Any) -> Callable[[dict], dict]:
    """Validate that zero keys exist or one key exists."""
    ...

def boolean(value: Any) -> bool:
    """Validate and coerce a boolean value."""
    ...

_WS = ...

def whitespace(value: Any) -> str:
    """Validate result contains only whitespace."""
    ...

def isdevice(value: Any) -> str:
    """Validate that value is a real device."""
    ...

def matches_regex(regex: str) -> Callable[[Any], str]:
    """Validate that the value is a string that matches a regex."""
    ...

def is_regex(value: Any) -> re.Pattern[Any]:
    """Validate that a string is a valid regular expression."""
    ...

def isfile(value: Any) -> str:
    """Validate that the value is an existing file."""
    ...

def isdir(value: Any) -> str:
    """Validate that the value is an existing dir."""
    ...

def ensure_list(value: T | list[T] | None) -> list[T]:
    """Wrap value in list if it is not one."""
    ...

def entity_id(value: Any) -> str:
    """Validate Entity ID."""
    ...

def entity_ids(value: str | list) -> list[str]:
    """Validate Entity IDs."""
    ...

comp_entity_ids = ...

def entity_domain(domain: str | list[str]) -> Callable[[Any], str]:
    """Validate that entity belong to domain."""
    ...

def entities_domain(domain: str | list[str]) -> Callable[[str | list], list[str]]:
    """Validate that entities belong to domain."""
    ...

def enum(enumClass: type[Enum]) -> vol.All:
    """Create validator for specified enum."""
    ...

def icon(value: Any) -> str:
    """Validate icon."""
    ...

time_period_dict = ...

def time(value: Any) -> time_sys:
    """Validate and transform a time."""
    ...

def date(value: Any) -> date_sys:
    """Validate and transform a date."""
    ...

def time_period_str(value: str) -> timedelta:
    """Validate and transform time offset."""
    ...

def time_period_seconds(value: float | str) -> timedelta:
    """Validate and transform seconds to a time offset."""
    ...

time_period = ...

def match_all(value: T) -> T:
    """Validate that matches all values."""
    ...

def positive_timedelta(value: timedelta) -> timedelta:
    """Validate timedelta is positive."""
    ...

positive_time_period_dict = ...
positive_time_period = ...

def remove_falsy(value: list[T]) -> list[T]:
    """Remove falsy values from a list."""
    ...

def service(value: Any) -> str:
    """Validate service."""
    ...

def slug(value: Any) -> str:
    """Validate value is a valid slug."""
    ...

def schema_with_slug_keys(
    value_schema: T | Callable, *, slug_validator: Callable[[Any], str] = ...
) -> Callable:
    """Ensure dicts have slugs as keys.

    Replacement of vol.Schema({cv.slug: value_schema}) to prevent misleading
    "Extra keys" errors from voluptuous.
    """
    ...

def slugify(value: Any) -> str:
    """Coerce a value to a slug."""
    ...

def string(value: Any) -> str:
    """Coerce value to string, except for None."""
    ...

def string_with_no_html(value: Any) -> str:
    """Validate that the value is a string without HTML."""
    ...

def temperature_unit(value: Any) -> str:
    """Validate and transform temperature unit."""
    ...

unit_system = ...

def template(value: Any | None) -> template_helper.Template:
    """Validate a jinja2 template."""
    ...

def dynamic_template(value: Any | None) -> template_helper.Template:
    """Validate a dynamic (non static) jinja2 template."""
    ...

def template_complex(value: Any) -> Any:
    """Validate a complex jinja2 template."""
    ...

positive_time_period_template = ...

def datetime(value: Any) -> datetime_sys:
    """Validate datetime."""
    ...

def time_zone(value: str) -> str:
    """Validate timezone."""
    ...

weekdays = ...

def socket_timeout(value: Any | None) -> object:
    """Validate timeout float > 0.0.

    None coerced to socket._GLOBAL_DEFAULT_TIMEOUT bare object.
    """
    ...

def url(value: Any) -> str:
    """Validate an URL."""
    ...

def url_no_path(value: Any) -> str:
    """Validate a url without a path."""
    ...

def x10_address(value: str) -> str:
    """Validate an x10 address."""
    ...

def uuid4_hex(value: Any) -> str:
    """Validate a v4 UUID in hex format."""
    ...

def ensure_list_csv(value: Any) -> list:
    """Ensure that input is a list or make one from comma-separated string."""
    ...

class multi_select:
    """Multi select validator returning list of selected values."""

    def __init__(self, options: dict) -> None:
        """Initialize multi select."""
        ...
    def __call__(self, selected: list) -> list:
        """Validate input."""
        ...

def deprecated(
    key: str, replacement_key: str | None = ..., default: Any | None = ...
) -> Callable[[dict], dict]:
    """
    Log key as deprecated and provide a replacement (if exists).

    Expected behavior:
        - Outputs the appropriate deprecation warning if key is detected
        - Processes schema moving the value from key to replacement_key
        - Processes schema changing nothing if only replacement_key provided
        - No warning if only replacement_key provided
        - No warning if neither key nor replacement_key are provided
            - Adds replacement_key with default value in this case
    """
    ...

def key_value_schemas(
    key: str, value_schemas: dict[Hashable, vol.Schema]
) -> Callable[[Any], dict[Hashable, Any]]:
    """Create a validator that validates based on a value for specific key.

    This gives better error messages.
    """
    ...

def key_dependency(
    key: Hashable, dependency: Hashable
) -> Callable[[dict[Hashable, Any]], dict[Hashable, Any]]:
    """Validate that all dependencies exist for key."""
    ...

def custom_serializer(schema: Any) -> Any:
    """Serialize additional types for voluptuous_serialize."""
    ...

PLATFORM_SCHEMA = ...
PLATFORM_SCHEMA_BASE = ...
ENTITY_SERVICE_FIELDS = ...

def make_entity_service_schema(schema: dict, *, extra: int = ...) -> vol.Schema:
    """Create an entity service schema."""
    ...

SCRIPT_VARIABLES_SCHEMA = ...

def script_action(value: Any) -> dict:
    """Validate a script action."""
    ...

SCRIPT_SCHEMA = ...
SCRIPT_ACTION_BASE_SCHEMA = ...
EVENT_SCHEMA = ...
SERVICE_SCHEMA = ...
NUMERIC_STATE_THRESHOLD_SCHEMA = ...
CONDITION_BASE_SCHEMA = ...
NUMERIC_STATE_CONDITION_SCHEMA = ...
STATE_CONDITION_BASE_SCHEMA = ...
STATE_CONDITION_STATE_SCHEMA = ...
STATE_CONDITION_ATTRIBUTE_SCHEMA = ...

def STATE_CONDITION_SCHEMA(value: Any) -> dict:
    """Validate a state condition."""
    ...

SUN_CONDITION_SCHEMA = ...
TEMPLATE_CONDITION_SCHEMA = ...
TIME_CONDITION_SCHEMA = ...
TRIGGER_CONDITION_SCHEMA = ...
ZONE_CONDITION_SCHEMA = ...
AND_CONDITION_SCHEMA = ...
OR_CONDITION_SCHEMA = ...
NOT_CONDITION_SCHEMA = ...
DEVICE_CONDITION_BASE_SCHEMA = ...
DEVICE_CONDITION_SCHEMA = ...
CONDITION_SCHEMA: vol.Schema = ...
TRIGGER_BASE_SCHEMA = ...
TRIGGER_SCHEMA = ...
_SCRIPT_DELAY_SCHEMA = ...
_SCRIPT_WAIT_TEMPLATE_SCHEMA = ...
DEVICE_ACTION_BASE_SCHEMA = ...
DEVICE_ACTION_SCHEMA = ...
_SCRIPT_SCENE_SCHEMA = ...
_SCRIPT_REPEAT_SCHEMA = ...
_SCRIPT_CHOOSE_SCHEMA = ...
_SCRIPT_WAIT_FOR_TRIGGER_SCHEMA = ...
_SCRIPT_SET_SCHEMA = ...
SCRIPT_ACTION_DELAY = ...
SCRIPT_ACTION_WAIT_TEMPLATE = ...
SCRIPT_ACTION_CHECK_CONDITION = ...
SCRIPT_ACTION_FIRE_EVENT = ...
SCRIPT_ACTION_CALL_SERVICE = ...
SCRIPT_ACTION_DEVICE_AUTOMATION = ...
SCRIPT_ACTION_ACTIVATE_SCENE = ...
SCRIPT_ACTION_REPEAT = ...
SCRIPT_ACTION_CHOOSE = ...
SCRIPT_ACTION_WAIT_FOR_TRIGGER = ...
SCRIPT_ACTION_VARIABLES = ...

def determine_script_action(action: dict[str, Any]) -> str:
    """Determine action type."""
    ...

ACTION_TYPE_SCHEMAS: dict[str, Callable[[Any], dict]] = ...
currency = ...
