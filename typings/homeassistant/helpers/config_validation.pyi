"""
This type stub file was generated by pyright.
"""

import re
import voluptuous as vol
from collections.abc import Callable, Hashable
from datetime import (
    date as date_sys,
    datetime as datetime_sys,
    time as time_sys,
    timedelta,
)
from enum import Enum, StrEnum
from typing import Any, TypeVar, overload
from homeassistant.const import UnitOfTemperature
from . import template as template_helper

"""Helpers for config validation using voluptuous."""
TIME_PERIOD_ERROR = ...

class UrlProtocolSchema(StrEnum):
    """Valid URL protocol schema values."""

    HTTP = ...
    HTTPS = ...
    HOMEASSISTANT = ...

EXTERNAL_URL_PROTOCOL_SCHEMA_LIST = ...
CONFIGURATION_URL_PROTOCOL_SCHEMA_LIST = ...
byte = ...
small_float = ...
positive_int = ...
positive_float = ...
latitude = ...
longitude = ...
gps = ...
sun_event = ...
port = ...
_T = TypeVar("_T")

def path(value: Any) -> str:
    """Validate it's a safe path."""
    ...

def has_at_least_one_key(*keys: Any) -> Callable[[dict], dict]:
    """Validate that at least one key exists."""
    ...

def has_at_most_one_key(*keys: Any) -> Callable[[dict], dict]:
    """Validate that zero keys exist or one key exists."""
    ...

def boolean(value: Any) -> bool:
    """Validate and coerce a boolean value."""
    ...

def whitespace(value: Any) -> str:
    """Validate result contains only whitespace."""
    ...

def isdevice(value: Any) -> str:
    """Validate that value is a real device."""
    ...

def matches_regex(regex: str) -> Callable[[Any], str]:
    """Validate that the value is a string that matches a regex."""
    ...

def is_regex(value: Any) -> re.Pattern[Any]:
    """Validate that a string is a valid regular expression."""
    ...

def isfile(value: Any) -> str:
    """Validate that the value is an existing file."""
    ...

def isdir(value: Any) -> str:
    """Validate that the value is an existing dir."""
    ...

@overload
def ensure_list(value: None) -> list[Any]: ...
@overload
def ensure_list(value: list[_T]) -> list[_T]: ...
@overload
def ensure_list(value: list[_T] | _T) -> list[_T]: ...
def ensure_list(value: _T | None) -> list[_T] | list[Any]:
    """Wrap value in list if it is not one."""
    ...

def entity_id(value: Any) -> str:
    """Validate Entity ID."""
    ...

def entity_id_or_uuid(value: Any) -> str:
    """Validate Entity specified by entity_id or uuid."""
    ...

def entity_ids(value: str | list) -> list[str]:
    """Validate Entity IDs."""
    ...

def entity_ids_or_uuids(value: str | list) -> list[str]:
    """Validate entities specified by entity IDs or UUIDs."""
    ...

comp_entity_ids = ...
comp_entity_ids_or_uuids = ...

def entity_domain(domain: str | list[str]) -> Callable[[Any], str]:
    """Validate that entity belong to domain."""
    ...

def entities_domain(domain: str | list[str]) -> Callable[[str | list], list[str]]:
    """Validate that entities belong to domain."""
    ...

def enum(enumClass: type[Enum]) -> vol.All:
    """Create validator for specified enum."""
    ...

def icon(value: Any) -> str:
    """Validate icon."""
    ...

_TIME_PERIOD_DICT_KEYS = ...
time_period_dict = ...

def time(value: Any) -> time_sys:
    """Validate and transform a time."""
    ...

def date(value: Any) -> date_sys:
    """Validate and transform a date."""
    ...

def time_period_str(value: str) -> timedelta:
    """Validate and transform time offset."""
    ...

def time_period_seconds(value: float | str) -> timedelta:
    """Validate and transform seconds to a time offset."""
    ...

time_period = ...

def match_all(value: _T) -> _T:
    """Validate that matches all values."""
    ...

def positive_timedelta(value: timedelta) -> timedelta:
    """Validate timedelta is positive."""
    ...

positive_time_period_dict = ...
positive_time_period = ...

def remove_falsy(value: list[_T]) -> list[_T]:
    """Remove falsy values from a list."""
    ...

def service(value: Any) -> str:
    """Validate service."""
    ...

def slug(value: Any) -> str:
    """Validate value is a valid slug."""
    ...

def schema_with_slug_keys(
    value_schema: _T | Callable, *, slug_validator: Callable[[Any], str] = ...
) -> Callable:
    """Ensure dicts have slugs as keys.

    Replacement of vol.Schema({cv.slug: value_schema}) to prevent misleading
    "Extra keys" errors from voluptuous.
    """
    ...

def slugify(value: Any) -> str:
    """Coerce a value to a slug."""
    ...

def string(value: Any) -> str:
    """Coerce value to string, except for None."""
    ...

def string_with_no_html(value: Any) -> str:
    """Validate that the value is a string without HTML."""
    ...

def temperature_unit(value: Any) -> UnitOfTemperature:
    """Validate and transform temperature unit."""
    ...

def template(value: Any | None) -> template_helper.Template:
    """Validate a jinja2 template."""
    ...

def dynamic_template(value: Any | None) -> template_helper.Template:
    """Validate a dynamic (non static) jinja2 template."""
    ...

def template_complex(value: Any) -> Any:
    """Validate a complex jinja2 template."""
    ...

positive_time_period_template = ...

def datetime(value: Any) -> datetime_sys:
    """Validate datetime."""
    ...

def time_zone(value: str) -> str:
    """Validate timezone."""
    ...

weekdays = ...

def socket_timeout(value: Any | None) -> object:
    """Validate timeout float > 0.0.

    None coerced to socket._GLOBAL_DEFAULT_TIMEOUT bare object.
    """
    ...

def url(value: Any, _schema_list: frozenset[UrlProtocolSchema] = ...) -> str:
    """Validate an URL."""
    ...

def configuration_url(value: Any) -> str:
    """Validate an URL that allows the homeassistant schema."""
    ...

def url_no_path(value: Any) -> str:
    """Validate a url without a path."""
    ...

def x10_address(value: str) -> str:
    """Validate an x10 address."""
    ...

def uuid4_hex(value: Any) -> str:
    """Validate a v4 UUID in hex format."""
    ...

_FAKE_UUID_4_HEX = ...

def fake_uuid4_hex(value: Any) -> str:
    """Validate a fake v4 UUID generated by random_uuid_hex."""
    ...

def ensure_list_csv(value: Any) -> list:
    """Ensure that input is a list or make one from comma-separated string."""
    ...

class multi_select:
    """Multi select validator returning list of selected values."""
    def __init__(self, options: dict | list) -> None:
        """Initialize multi select."""
        ...

    def __call__(self, selected: list) -> list:
        """Validate input."""
        ...

def deprecated(
    key: str,
    replacement_key: str | None = ...,
    default: Any | None = ...,
    raise_if_present: bool | None = ...,
) -> Callable[[dict], dict]:
    """Log key as deprecated and provide a replacement (if exists).

    Expected behavior:
        - Outputs the appropriate deprecation warning if key is detected
          or raises an exception
        - Processes schema moving the value from key to replacement_key
        - Processes schema changing nothing if only replacement_key provided
        - No warning if only replacement_key provided
        - No warning if neither key nor replacement_key are provided
            - Adds replacement_key with default value in this case
    """
    ...

def removed(
    key: str, default: Any | None = ..., raise_if_present: bool | None = ...
) -> Callable[[dict], dict]:
    """Log key as deprecated and fail the config validation.

    Expected behavior:
        - Outputs the appropriate error if key is detected and removed from
          support or raises an exception.
    """
    ...

def key_value_schemas(
    key: str,
    value_schemas: dict[Hashable, vol.Schema],
    default_schema: vol.Schema | None = ...,
    default_description: str | None = ...,
) -> Callable[[Any], dict[Hashable, Any]]:
    """Create a validator that validates based on a value for specific key.

    This gives better error messages.
    """
    ...

def key_dependency(
    key: Hashable, dependency: Hashable
) -> Callable[[dict[Hashable, Any]], dict[Hashable, Any]]:
    """Validate that all dependencies exist for key."""
    ...

def custom_serializer(schema: Any) -> Any:
    """Serialize additional types for voluptuous_serialize."""
    ...

def expand_condition_shorthand(value: Any | None) -> Any:
    """Expand boolean condition shorthand notations."""
    ...

def empty_config_schema(domain: str) -> Callable[[dict], dict]:
    """Return a config schema which logs if there are configuration parameters."""
    ...

def config_entry_only_config_schema(domain: str) -> Callable[[dict], dict]:
    """Return a config schema which logs if attempted to setup from YAML.

    Use this when an integration's __init__.py defines setup or async_setup
    but setup from yaml is not supported.
    """
    ...

def platform_only_config_schema(domain: str) -> Callable[[dict], dict]:
    """Return a config schema which logs if attempted to setup from YAML.

    Use this when an integration's __init__.py defines setup or async_setup
    but setup from the integration key is not supported.
    """
    ...

PLATFORM_SCHEMA = ...
PLATFORM_SCHEMA_BASE = ...
ENTITY_SERVICE_FIELDS = ...
TARGET_SERVICE_FIELDS = ...

def make_entity_service_schema(schema: dict, *, extra: int = ...) -> vol.Schema:
    """Create an entity service schema."""
    ...

SCRIPT_VARIABLES_SCHEMA = ...

def script_action(value: Any) -> dict:
    """Validate a script action."""
    ...

SCRIPT_SCHEMA = ...
SCRIPT_ACTION_BASE_SCHEMA = ...
EVENT_SCHEMA = ...
SERVICE_SCHEMA = ...
NUMERIC_STATE_THRESHOLD_SCHEMA = ...
CONDITION_BASE_SCHEMA = ...
NUMERIC_STATE_CONDITION_SCHEMA = ...
STATE_CONDITION_BASE_SCHEMA = ...
STATE_CONDITION_STATE_SCHEMA = ...
STATE_CONDITION_ATTRIBUTE_SCHEMA = ...

def STATE_CONDITION_SCHEMA(value: Any) -> dict:
    """Validate a state condition."""
    ...

SUN_CONDITION_SCHEMA = ...
TEMPLATE_CONDITION_SCHEMA = ...
TIME_CONDITION_SCHEMA = ...
TRIGGER_CONDITION_SCHEMA = ...
ZONE_CONDITION_SCHEMA = ...
AND_CONDITION_SCHEMA = ...
AND_CONDITION_SHORTHAND_SCHEMA = ...
OR_CONDITION_SCHEMA = ...
OR_CONDITION_SHORTHAND_SCHEMA = ...
NOT_CONDITION_SCHEMA = ...
NOT_CONDITION_SHORTHAND_SCHEMA = ...
DEVICE_CONDITION_BASE_SCHEMA = ...
DEVICE_CONDITION_SCHEMA = ...
dynamic_template_condition_action = ...
CONDITION_SHORTHAND_SCHEMA = ...
CONDITION_SCHEMA: vol.Schema = ...
CONDITIONS_SCHEMA = ...
dynamic_template_condition_action = ...
CONDITION_ACTION_SCHEMA: vol.Schema = ...
TRIGGER_BASE_SCHEMA = ...
_base_trigger_validator_schema = ...
TRIGGER_SCHEMA = ...
_SCRIPT_DELAY_SCHEMA = ...
_SCRIPT_WAIT_TEMPLATE_SCHEMA = ...
DEVICE_ACTION_BASE_SCHEMA = ...
DEVICE_ACTION_SCHEMA = ...
_SCRIPT_SCENE_SCHEMA = ...
_SCRIPT_REPEAT_SCHEMA = ...
_SCRIPT_CHOOSE_SCHEMA = ...
_SCRIPT_WAIT_FOR_TRIGGER_SCHEMA = ...
_SCRIPT_IF_SCHEMA = ...
_SCRIPT_SET_SCHEMA = ...
_SCRIPT_STOP_SCHEMA = ...
_SCRIPT_PARALLEL_SEQUENCE = ...
_parallel_sequence_action = ...
_SCRIPT_PARALLEL_SCHEMA = ...
SCRIPT_ACTION_DELAY = ...
SCRIPT_ACTION_WAIT_TEMPLATE = ...
SCRIPT_ACTION_CHECK_CONDITION = ...
SCRIPT_ACTION_FIRE_EVENT = ...
SCRIPT_ACTION_CALL_SERVICE = ...
SCRIPT_ACTION_DEVICE_AUTOMATION = ...
SCRIPT_ACTION_ACTIVATE_SCENE = ...
SCRIPT_ACTION_REPEAT = ...
SCRIPT_ACTION_CHOOSE = ...
SCRIPT_ACTION_WAIT_FOR_TRIGGER = ...
SCRIPT_ACTION_VARIABLES = ...
SCRIPT_ACTION_STOP = ...
SCRIPT_ACTION_IF = ...
SCRIPT_ACTION_PARALLEL = ...

def determine_script_action(action: dict[str, Any]) -> str:
    """Determine action type."""
    ...

ACTION_TYPE_SCHEMAS: dict[str, Callable[[Any], dict]] = ...
currency = ...
historic_currency = ...
country = ...
language = ...
