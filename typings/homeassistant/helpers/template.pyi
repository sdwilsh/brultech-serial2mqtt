"""
This type stub file was generated by pyright.
"""

import jinja2
from collections.abc import Callable, Generator, Iterable, MutableMapping
from contextlib import AbstractContextManager
from contextvars import ContextVar
from datetime import datetime, timedelta
from types import CodeType, TracebackType
from typing import Any, Literal, NoReturn, TypeVar, overload
from jinja2 import pass_context
from jinja2.sandbox import ImmutableSandboxedEnvironment
from homeassistant.core import Context, HomeAssistant, State, callback
from homeassistant.loader import bind_hass
from homeassistant.util.read_only_dict import ReadOnlyDict
from .typing import TemplateVarsType

"""Template helper methods for rendering strings with Home Assistant data."""
_LOGGER = ...
_SENTINEL = ...
DATE_STR_FORMAT = ...
_ENVIRONMENT = ...
_ENVIRONMENT_LIMITED = ...
_ENVIRONMENT_STRICT = ...
_HASS_LOADER = ...
_RE_JINJA_DELIMITERS = ...
_IS_NUMERIC = ...
_RESERVED_NAMES = ...
_GROUP_DOMAIN_PREFIX = ...
_ZONE_DOMAIN_PREFIX = ...
_COLLECTABLE_STATE_ATTRIBUTES = ...
_T = TypeVar("_T")
_R = TypeVar("_R")
_P = ...
ALL_STATES_RATE_LIMIT = ...
DOMAIN_STATES_RATE_LIMIT = ...
_render_info: ContextVar[RenderInfo | None] = ...
template_cv: ContextVar[tuple[str, str] | None] = ...
CACHED_TEMPLATE_STATES = ...
EVAL_CACHE_SIZE = ...
MAX_CUSTOM_TEMPLATE_SIZE = ...
CACHED_TEMPLATE_LRU: MutableMapping[State, TemplateState] = ...
CACHED_TEMPLATE_NO_COLLECT_LRU: MutableMapping[State, TemplateState] = ...
ENTITY_COUNT_GROWTH_FACTOR = ...
ORJSON_PASSTHROUGH_OPTIONS = ...

def async_setup(hass: HomeAssistant) -> bool:
    """Set up tracking the template LRUs."""
    ...

@bind_hass
def attach(hass: HomeAssistant, obj: Any) -> None:
    """Recursively attach hass to all template instances in list and dict."""
    ...

def render_complex(
    value: Any,
    variables: TemplateVarsType = ...,
    limited: bool = ...,
    parse_result: bool = ...,
) -> Any:
    """Recursive template creator helper function."""
    ...

def is_complex(value: Any) -> bool:
    """Test if data structure is a complex template."""
    ...

def is_template_string(maybe_template: str) -> bool:
    """Check if the input is a Jinja2 template."""
    ...

class ResultWrapper:
    """Result wrapper class to store render result."""

    render_result: str | None
    ...

def gen_result_wrapper(kls: type[dict | list | set]) -> type:
    """Generate a result wrapper."""
    class Wrapper(kls, ResultWrapper):
        """Wrapper of a kls that can store render_result."""

        ...

class TupleWrapper(tuple, ResultWrapper):
    """Wrap a tuple."""
    def __new__(cls, value: tuple, *, render_result: str | None = ...) -> TupleWrapper:
        """Create a new tuple class."""
        ...

    def __init__(self, value: tuple, *, render_result: str | None = ...) -> None:
        """Initialize a new tuple class."""
        ...

    def __str__(self) -> str:
        """Return string representation."""
        ...

_types: tuple[type[dict | list | set], ...] = ...
RESULT_WRAPPERS: dict[type, type] = ...
_cached_literal_eval = ...

class RenderInfo:
    """Holds information about a template render."""

    __slots__ = ...
    def __init__(self, template: Template) -> None:
        """Initialise."""
        ...

    def __repr__(self) -> str:
        """Representation of RenderInfo."""
        ...

    def result(self) -> str:
        """Results of the template computation."""
        ...

class Template:
    """Class to hold a template and manage caching and rendering."""

    __slots__ = ...
    def __init__(self, template: str, hass: HomeAssistant | None = ...) -> None:
        """Instantiate a template."""
        ...

    def ensure_valid(self) -> None:
        """Return if template is valid."""
        ...

    def render(
        self,
        variables: TemplateVarsType = ...,
        parse_result: bool = ...,
        limited: bool = ...,
        **kwargs: Any,
    ) -> Any:
        """Render given template.

        If limited is True, the template is not allowed to access any function
        or filter depending on hass or the state machine.
        """
        ...

    @callback
    def async_render(
        self,
        variables: TemplateVarsType = ...,
        parse_result: bool = ...,
        limited: bool = ...,
        strict: bool = ...,
        log_fn: Callable[[int, str], None] | None = ...,
        **kwargs: Any,
    ) -> Any:
        """Render given template.

        This method must be run in the event loop.

        If limited is True, the template is not allowed to access any function
        or filter depending on hass or the state machine.
        """
        ...

    async def async_render_will_timeout(
        self,
        timeout: float,
        variables: TemplateVarsType = ...,
        strict: bool = ...,
        log_fn: Callable[[int, str], None] | None = ...,
        **kwargs: Any,
    ) -> bool:
        """Check to see if rendering a template will timeout during render.

        This is intended to check for expensive templates
        that will make the system unstable.  The template
        is rendered in the executor to ensure it does not
        tie up the event loop.

        This function is not a security control and is only
        intended to be used as a safety check when testing
        templates.

        This method must be run in the event loop.
        """
        ...

    @callback
    def async_render_to_info(
        self,
        variables: TemplateVarsType = ...,
        strict: bool = ...,
        log_fn: Callable[[int, str], None] | None = ...,
        **kwargs: Any,
    ) -> RenderInfo:
        """Render the template and collect an entity filter."""
        ...

    def render_with_possible_json_value(self, value, error_value=...):  # -> str | Any:
        """Render template with value exposed.

        If valid JSON will expose value_json too.
        """
        ...

    @callback
    def async_render_with_possible_json_value(
        self, value: Any, error_value: Any = ..., variables: dict[str, Any] | None = ...
    ) -> Any:
        """Render template with value exposed.

        If valid JSON will expose value_json too.

        This method must be run in the event loop.
        """
        ...

    def __eq__(self, other) -> bool:
        """Compare template with another."""
        ...

    def __hash__(self) -> int:
        """Hash code for template."""
        ...

    def __repr__(self) -> str:
        """Representation of Template."""
        ...

class AllStates:
    """Class to expose all HA states as attributes."""

    __setitem__ = ...
    __delitem__ = ...
    __slots__ = ...
    def __init__(self, hass: HomeAssistant) -> None:
        """Initialize all states."""
        ...

    def __getattr__(self, name):  # -> TemplateState | DomainStates | None:
        """Return the domain state."""
        ...

    __getitem__ = ...
    def __iter__(self) -> Generator[TemplateState, None, None]:
        """Return all states."""
        ...

    def __len__(self) -> int:
        """Return number of states."""
        ...

    def __call__(
        self, entity_id: str, rounded: bool | object = ..., with_unit: bool = ...
    ) -> str:
        """Return the states."""
        ...

    def __repr__(self) -> str:
        """Representation of All States."""
        ...

class DomainStates:
    """Class to expose a specific HA domain as attributes."""

    __slots__ = ...
    __setitem__ = ...
    __delitem__ = ...
    def __init__(self, hass: HomeAssistant, domain: str) -> None:
        """Initialize the domain states."""
        ...

    def __getattr__(self, name: str) -> TemplateState | None:
        """Return the states."""
        ...

    __getitem__ = ...
    def __iter__(self) -> Generator[TemplateState, None, None]:
        """Return the iteration over all the states."""
        ...

    def __len__(self) -> int:
        """Return number of states."""
        ...

    def __repr__(self) -> str:
        """Representation of Domain States."""
        ...

class TemplateStateBase(State):
    """Class to represent a state object in a template."""

    _state: State
    __setitem__ = ...
    __delitem__ = ...
    def __init__(self, hass: HomeAssistant, collect: bool, entity_id: str) -> None:
        """Initialize template state."""
        ...

    def __getitem__(self, item: str) -> Any:
        """Return a property as an attribute for jinja."""
        ...

    @property
    def entity_id(self) -> str:
        """Wrap State.entity_id.

        Intentionally does not collect state
        """
        ...

    @property
    def state(self) -> str:
        """Wrap State.state."""
        ...

    @property
    def attributes(self) -> ReadOnlyDict[str, Any]:
        """Wrap State.attributes."""
        ...

    @property
    def last_changed(self) -> datetime:
        """Wrap State.last_changed."""
        ...

    @property
    def last_updated(self) -> datetime:
        """Wrap State.last_updated."""
        ...

    @property
    def context(self) -> Context:
        """Wrap State.context."""
        ...

    @property
    def domain(self) -> str:
        """Wrap State.domain."""
        ...

    @property
    def object_id(self) -> str:
        """Wrap State.object_id."""
        ...

    @property
    def name(self) -> str:
        """Wrap State.name."""
        ...

    @property
    def state_with_unit(self) -> str:
        """Return the state concatenated with the unit if available."""
        ...

    def format_state(self, rounded: bool, with_unit: bool) -> str:
        """Return a formatted version of the state."""
        ...

    def __eq__(self, other: Any) -> bool:
        """Ensure we collect on equality check."""
        ...

class TemplateState(TemplateStateBase):
    """Class to represent a state object in a template."""

    __slots__ = ...
    def __init__(self, hass: HomeAssistant, state: State, collect: bool = ...) -> None:
        """Initialize template state."""
        ...

    def __repr__(self) -> str:
        """Representation of Template State."""
        ...

class TemplateStateFromEntityId(TemplateStateBase):
    """Class to represent a state object in a template."""
    def __init__(
        self, hass: HomeAssistant, entity_id: str, collect: bool = ...
    ) -> None:
        """Initialize template state."""
        ...

    def __repr__(self) -> str:
        """Representation of Template State."""
        ...

_create_template_state_no_collect = ...

@overload
def forgiving_boolean(value: Any) -> bool | object: ...
@overload
def forgiving_boolean(value: Any, default: _T) -> bool | _T: ...
def forgiving_boolean(value: Any, default: _T | object = ...) -> bool | _T | object:
    """Try to convert value to a boolean."""
    ...

def result_as_boolean(template_result: Any | None) -> bool:
    """Convert the template result to a boolean.

    True/not 0/'1'/'true'/'yes'/'on'/'enable' are considered truthy
    False/0/None/'0'/'false'/'no'/'off'/'disable' are considered falsy

    """
    ...

def expand(hass: HomeAssistant, *args: Any) -> Iterable[State]:
    """Expand out any groups and zones into entity states."""
    ...

def device_entities(hass: HomeAssistant, _device_id: str) -> Iterable[str]:
    """Get entity ids for entities tied to a device."""
    ...

def integration_entities(hass: HomeAssistant, entry_name: str) -> Iterable[str]:
    """Get entity ids for entities tied to an integration/domain.

    Provide entry_name as domain to get all entity id's for a integration/domain
    or provide a config entry title for filtering between instances of the same
    integration.
    """
    ...

def config_entry_id(hass: HomeAssistant, entity_id: str) -> str | None:
    """Get an config entry ID from an entity ID."""
    ...

def device_id(hass: HomeAssistant, entity_id_or_device_name: str) -> str | None:
    """Get a device ID from an entity ID or device name."""
    ...

def device_attr(hass: HomeAssistant, device_or_entity_id: str, attr_name: str) -> Any:
    """Get the device specific attribute."""
    ...

def is_device_attr(
    hass: HomeAssistant, device_or_entity_id: str, attr_name: str, attr_value: Any
) -> bool:
    """Test if a device's attribute is a specific value."""
    ...

def areas(hass: HomeAssistant) -> Iterable[str | None]:
    """Return all areas."""
    ...

def area_id(hass: HomeAssistant, lookup_value: str) -> str | None:
    """Get the area ID from an area name, device id, or entity id."""
    ...

def area_name(hass: HomeAssistant, lookup_value: str) -> str | None:
    """Get the area name from an area id, device id, or entity id."""
    ...

def area_entities(hass: HomeAssistant, area_id_or_name: str) -> Iterable[str]:
    """Return entities for a given area ID or name."""
    ...

def area_devices(hass: HomeAssistant, area_id_or_name: str) -> Iterable[str]:
    """Return device IDs for a given area ID or name."""
    ...

def closest(hass, *args):  # -> State | None:
    """Find closest entity.

    Closest to home:
        closest(states)
        closest(states.device_tracker)
        closest('group.children')
        closest(states.group.children)

    Closest to a point:
        closest(23.456, 23.456, 'group.children')
        closest('zone.school', 'group.children')
        closest(states.zone.school, 'group.children')

    As a filter:
        states | closest
        states.device_tracker | closest
        ['group.children', states.device_tracker] | closest
        'group.children' | closest(23.456, 23.456)
        states.device_tracker | closest('zone.school')
        'group.children' | closest(states.zone.school)

    """
    ...

def closest_filter(hass, *args):  # -> State | None:
    """Call closest as a filter. Need to reorder arguments."""
    ...

def distance(hass, *args):  # -> None:
    """Calculate distance.

    Will calculate distance from home to a point or between points.
    Points can be passed in using state objects or lat/lng coordinates.
    """
    ...

def is_hidden_entity(hass: HomeAssistant, entity_id: str) -> bool:
    """Test if an entity is hidden."""
    ...

def is_state(hass: HomeAssistant, entity_id: str, state: str | list[str]) -> bool:
    """Test if a state is a specific value."""
    ...

def is_state_attr(hass: HomeAssistant, entity_id: str, name: str, value: Any) -> bool:
    """Test if a state's attribute is a specific value."""
    ...

def state_attr(hass: HomeAssistant, entity_id: str, name: str) -> Any:
    """Get a specific attribute from a state."""
    ...

def has_value(hass: HomeAssistant, entity_id: str) -> bool:
    """Test if an entity has a valid value."""
    ...

def now(hass: HomeAssistant) -> datetime:
    """Record fetching now."""
    ...

def utcnow(hass: HomeAssistant) -> datetime:
    """Record fetching utcnow."""
    ...

def raise_no_default(function: str, value: Any) -> NoReturn:
    """Log warning if no default is specified."""
    ...

def forgiving_round(
    value, precision=..., method=..., default=...
):  # -> int | float | object:
    """Filter to round a value."""
    ...

def multiply(value, amount, default=...):  # -> object:
    """Filter to convert value to float and multiply it."""
    ...

def logarithm(value, base=..., default=...):  # -> object | float:
    """Filter and function to get logarithm of the value with a specific base."""
    ...

def sine(value, default=...):  # -> float | object:
    """Filter and function to get sine of the value."""
    ...

def cosine(value, default=...):  # -> float | object:
    """Filter and function to get cosine of the value."""
    ...

def tangent(value, default=...):  # -> float | object:
    """Filter and function to get tangent of the value."""
    ...

def arc_sine(value, default=...):  # -> float | object:
    """Filter and function to get arc sine of the value."""
    ...

def arc_cosine(value, default=...):  # -> float | object:
    """Filter and function to get arc cosine of the value."""
    ...

def arc_tangent(value, default=...):  # -> float | object:
    """Filter and function to get arc tangent of the value."""
    ...

def arc_tangent2(*args, default=...):  # -> float | object:
    """Filter and function to calculate four quadrant arc tangent of y / x.

    The parameters to atan2 may be passed either in an iterable or as separate arguments
    The default value may be passed either as a positional or in a keyword argument
    """
    ...

def version(value):  # -> AwesomeVersion:
    """Filter and function to get version object of the value."""
    ...

def square_root(value, default=...):  # -> float | object:
    """Filter and function to get square root of the value."""
    ...

def timestamp_custom(
    value, date_format=..., local=..., default=...
):  # -> str | object:
    """Filter to convert given timestamp to format."""
    ...

def timestamp_local(value, default=...):  # -> str | object:
    """Filter to convert given timestamp to local date/time."""
    ...

def timestamp_utc(value, default=...):  # -> str | object:
    """Filter to convert given timestamp to UTC date/time."""
    ...

def forgiving_as_timestamp(value, default=...):  # -> float | object:
    """Filter and function which tries to convert value to timestamp."""
    ...

def as_datetime(value):  # -> datetime | None:
    """Filter and to convert a time string or UNIX timestamp to datetime object."""
    ...

def as_timedelta(value: str) -> timedelta | None:
    """Parse a ISO8601 duration like 'PT10M' to a timedelta."""
    ...

def strptime(string, fmt, default=...):  # -> datetime | object:
    """Parse a time string to datetime."""
    ...

def fail_when_undefined(value):
    """Filter to force a failure when the value is undefined."""
    ...

def min_max_from_filter(builtin_filter: Any, name: str) -> Any:
    """Convert a built-in min/max Jinja filter to a global function.

    The parameters may be passed as an iterable or as separate arguments.
    """
    ...

def average(*args: Any, default: Any = ...) -> Any:
    """Filter and function to calculate the arithmetic mean.

    Calculates of an iterable or of two or more arguments.

    The parameters may be passed as an iterable or as separate arguments.
    """
    ...

def forgiving_float(value, default=...):  # -> float | object:
    """Try to convert value to a float."""
    ...

def forgiving_float_filter(value, default=...):  # -> float | object:
    """Try to convert value to a float."""
    ...

def forgiving_int(value, default=..., base=...):
    """Try to convert value to an int, and raise if it fails."""
    ...

def forgiving_int_filter(value, default=..., base=...):
    """Try to convert value to an int, and raise if it fails."""
    ...

def is_number(value):  # -> bool:
    """Try to convert value to a float."""
    ...

def regex_match(value, find=..., ignorecase=...):  # -> bool:
    """Match value using regex."""
    ...

_regex_cache = ...

def regex_replace(
    value=..., find=..., replace=..., ignorecase=...
):  # -> AnyStr@compile:
    """Replace using regex."""
    ...

def regex_search(value, find=..., ignorecase=...):  # -> bool:
    """Search using regex."""
    ...

def regex_findall_index(
    value, find=..., index=..., ignorecase=...
):  # -> AnyStr@compile:
    """Find all matches using regex and then pick specific match index."""
    ...

def regex_findall(value, find=..., ignorecase=...):  # -> list[AnyStr@compile]:
    """Find all matches using regex."""
    ...

def bitwise_and(first_value, second_value):
    """Perform a bitwise and operation."""
    ...

def bitwise_or(first_value, second_value):
    """Perform a bitwise or operation."""
    ...

def struct_pack(value: Any | None, format_string: str) -> bytes | None:
    """Pack an object into a bytes object."""
    ...

def struct_unpack(value: bytes, format_string: str, offset: int = ...) -> Any | None:
    """Unpack an object from bytes an return the first native object."""
    ...

def base64_encode(value):  # -> str:
    """Perform base64 encode."""
    ...

def base64_decode(value):  # -> str:
    """Perform base64 denode."""
    ...

def ordinal(value):  # -> str:
    """Perform ordinal conversion."""
    ...

def from_json(value):  # -> JsonValueType:
    """Convert a JSON string to an object."""
    ...

def to_json(
    value: Any,
    ensure_ascii: bool = ...,
    pretty_print: bool = ...,
    sort_keys: bool = ...,
) -> str:
    """Convert an object to a JSON string."""
    ...

@pass_context
def random_every_time(context, values):
    """Choose a random value.

    Unlike Jinja's random filter,
    this is context-dependent to avoid caching the chosen value.
    """
    ...

def today_at(hass: HomeAssistant, time_str: str = ...) -> datetime:
    """Record fetching now where the time has been replaced with value."""
    ...

def relative_time(hass: HomeAssistant, value: Any) -> Any:
    """Take a datetime and return its "age" as a string.

    The age can be in second, minute, hour, day, month or year. Only the
    biggest unit is considered, e.g. if it's 2 days and 3 hours, "2 days" will
    be returned.
    Make sure date is not in the future, or else it will return None.

    If the input are not a datetime object the input will be returned unmodified.
    """
    ...

def urlencode(value):  # -> bytes:
    """Urlencode dictionary and return as UTF-8 string."""
    ...

def slugify(value, separator=...):  # -> str:
    """Convert a string into a slug, such as what is used for entity ids."""
    ...

def iif(value: Any, if_true: Any = ..., if_false: Any = ..., if_none: Any = ...) -> Any:
    """Immediate if function/filter that allow for common if/else constructs.

    https://en.wikipedia.org/wiki/IIf

    Examples:
        {{ is_state("device_tracker.frenck", "home") | iif("yes", "no") }}
        {{ iif(1==2, "yes", "no") }}
        {{ (1 == 1) | iif("yes", "no") }}
    """
    ...

class TemplateContextManager(AbstractContextManager):
    """Context manager to store template being parsed or rendered in a ContextVar."""
    def set_template(self, template_str: str, action: str) -> None:
        """Store template being parsed or rendered in a Contextvar to aid error handling."""
        ...

    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None:
        """Raise any exception triggered within the runtime context."""
        ...

_template_context_manager = ...

def make_logging_undefined(
    strict: bool | None, log_fn: Callable[[int, str], None] | None
) -> type[jinja2.Undefined]:
    """Log on undefined variables."""
    class LoggingUndefined(jinja2.Undefined):
        """Log on undefined variables."""

        ...

async def async_load_custom_templates(hass: HomeAssistant) -> None:
    """Load all custom jinja files under 5MiB into memory."""
    ...

class HassLoader(jinja2.BaseLoader):
    """An in-memory jinja loader that keeps track of templates that need to be reloaded."""
    def __init__(self, sources: dict[str, str]) -> None:
        """Initialize an empty HassLoader."""
        ...

    @property
    def sources(self) -> dict[str, str]:
        """Map filename to jinja source."""
        ...

    @sources.setter
    def sources(self, value: dict[str, str]) -> None: ...
    def get_source(
        self, environment: jinja2.Environment, template: str
    ) -> tuple[str, str | None, Callable[[], bool] | None]:
        """Get in-memory sources."""
        ...

class TemplateEnvironment(ImmutableSandboxedEnvironment):
    """The Home Assistant template environment."""
    def __init__(
        self,
        hass: HomeAssistant | None,
        limited: bool | None = ...,
        strict: bool | None = ...,
        log_fn: Callable[[int, str], None] | None = ...,
    ) -> None:
        """Initialise template environment."""
        ...

    def is_safe_callable(self, obj):  # -> bool:
        """Test if callback is safe."""
        ...

    def is_safe_attribute(self, obj, attr, value):  # -> bool:
        """Test if attribute is safe."""
        ...

    @overload
    def compile(
        self,
        source: str | jinja2.nodes.Template,
        name: str | None = ...,
        filename: str | None = ...,
        raw: Literal[False] = ...,
        defer_init: bool = ...,
    ) -> CodeType: ...
    @overload
    def compile(
        self,
        source: str | jinja2.nodes.Template,
        name: str | None = ...,
        filename: str | None = ...,
        raw: Literal[True] = ...,
        defer_init: bool = ...,
    ) -> str: ...
    def compile(
        self,
        source: str | jinja2.nodes.Template,
        name: str | None = ...,
        filename: str | None = ...,
        raw: bool = ...,
        defer_init: bool = ...,
    ) -> CodeType | str:
        """Compile the template."""
        ...

_NO_HASS_ENV = ...
