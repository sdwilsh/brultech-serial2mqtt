"""
This type stub file was generated by pyright.
"""

import logging
from collections.abc import Callable, Sequence
from contextlib import asynccontextmanager
from types import MappingProxyType
from typing import Any, Dict, TypedDict, Union

from homeassistant.core import Context, HomeAssistant, callback
from homeassistant.helpers.condition import ConditionCheckerType
from homeassistant.helpers.script_variables import ScriptVariables
from homeassistant.helpers.typing import ConfigType

"""Helpers to execute scripts."""
SCRIPT_MODE_PARALLEL = ...
SCRIPT_MODE_QUEUED = ...
SCRIPT_MODE_RESTART = ...
SCRIPT_MODE_SINGLE = ...
SCRIPT_MODE_CHOICES = ...
DEFAULT_SCRIPT_MODE = ...
CONF_MAX = ...
DEFAULT_MAX = ...
CONF_MAX_EXCEEDED = ...
_MAX_EXCEEDED_CHOICES = ...
DEFAULT_MAX_EXCEEDED = ...
ATTR_CUR = ...
ATTR_MAX = ...
DATA_SCRIPTS = ...
DATA_SCRIPT_BREAKPOINTS = ...
RUN_ID_ANY = ...
NODE_ANY = ...
_LOGGER = ...
_LOG_EXCEPTION = ...
_TIMEOUT_MSG = ...
_SHUTDOWN_MAX_WAIT = ...
ACTION_TRACE_NODE_MAX_LEN = ...
SCRIPT_BREAKPOINT_HIT = ...
SCRIPT_DEBUG_CONTINUE_STOP = ...
SCRIPT_DEBUG_CONTINUE_ALL = ...

def action_trace_append(variables, path):  # -> TraceElement:
    """Append a TraceElement to trace[path]."""
    ...

@asynccontextmanager
async def trace_action(hass, script_run, stop, variables):
    """Trace action execution."""
    ...

def make_script_schema(schema, default_script_mode, extra=...):  # -> Schema:
    """Make a schema for a component that uses the script helper."""
    ...

STATIC_VALIDATION_ACTION_TYPES = ...

async def async_validate_actions_config(
    hass: HomeAssistant, actions: list[ConfigType]
) -> list[ConfigType]:
    """Validate a list of actions."""
    ...

async def async_validate_action_config(
    hass: HomeAssistant, config: ConfigType
) -> ConfigType:
    """Validate config."""
    ...

class _StopScript(Exception):
    """Throw if script needs to stop."""

    ...

class _ScriptRun:
    """Manage Script sequence run."""

    def __init__(
        self,
        hass: HomeAssistant,
        script: Script,
        variables: dict[str, Any],
        context: Context | None,
        log_exceptions: bool,
    ) -> None: ...
    async def async_run(self) -> None:
        """Run script."""
        ...
    async def async_stop(self) -> None:
        """Stop script run."""
        ...

class _QueuedScriptRun(_ScriptRun):
    """Manage queued Script sequence run."""

    lock_acquired = ...
    async def async_run(self) -> None:
        """Run script."""
        ...

_VarsType = Union[Dict[str, Any], MappingProxyType]

class _ChooseData(TypedDict):
    choices: list[tuple[list[ConditionCheckerType], Script]]
    default: Script | None
    ...

class Script:
    """Representation of a script."""

    def __init__(
        self,
        hass: HomeAssistant,
        sequence: Sequence[dict[str, Any]],
        name: str,
        domain: str,
        *,
        running_description: str | None = ...,
        change_listener: Callable[..., Any] | None = ...,
        script_mode: str = ...,
        max_runs: int = ...,
        max_exceeded: str = ...,
        logger: logging.Logger | None = ...,
        log_exceptions: bool = ...,
        top_level: bool = ...,
        variables: ScriptVariables | None = ...
    ) -> None:
        """Initialize the script."""
        ...
    @property
    def change_listener(self) -> Callable[..., Any] | None:
        """Return the change_listener."""
        ...
    @change_listener.setter
    def change_listener(self, change_listener: Callable[..., Any]) -> None:
        """Update the change_listener."""
        ...
    def update_logger(self, logger: logging.Logger | None = ...) -> None:
        """Update logger."""
        ...
    @property
    def is_running(self) -> bool:
        """Return true if script is on."""
        ...
    @property
    def runs(self) -> int:
        """Return the number of current runs."""
        ...
    @property
    def supports_max(self) -> bool:
        """Return true if the current mode support max."""
        ...
    @property
    def referenced_areas(self):  # -> set[str]:
        """Return a set of referenced areas."""
        ...
    @property
    def referenced_devices(self):  # -> set[str]:
        """Return a set of referenced devices."""
        ...
    @property
    def referenced_entities(self):  # -> set[str]:
        """Return a set of referenced entities."""
        ...
    def run(
        self, variables: _VarsType | None = ..., context: Context | None = ...
    ) -> None:
        """Run script."""
        ...
    async def async_run(
        self,
        run_variables: _VarsType | None = ...,
        context: Context | None = ...,
        started_action: Callable[..., Any] | None = ...,
    ) -> None:
        """Run script."""
        ...
    async def async_stop(
        self, update_state: bool = ..., spare: _ScriptRun | None = ...
    ) -> None:
        """Stop running script."""
        ...

@callback
def breakpoint_clear(hass, key, run_id, node):  # -> None:
    """Clear a breakpoint."""
    ...

@callback
def breakpoint_clear_all(hass: HomeAssistant) -> None:
    """Clear all breakpoints."""
    ...

@callback
def breakpoint_set(hass, key, run_id, node):  # -> None:
    """Set a breakpoint."""
    ...

@callback
def breakpoint_list(hass: HomeAssistant) -> list[dict[str, Any]]:
    """List breakpoints."""
    ...

@callback
def debug_continue(hass, key, run_id):  # -> None:
    """Continue execution of a halted script."""
    ...

@callback
def debug_step(hass, key, run_id):  # -> None:
    """Single step a halted script."""
    ...

@callback
def debug_stop(hass, key, run_id):  # -> None:
    """Stop execution of a running or halted script."""
    ...
