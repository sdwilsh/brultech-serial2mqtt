"""
This type stub file was generated by pyright.
"""

from __future__ import annotations

import abc
import datetime as dt
import logging
from collections import deque
from typing import Any

import homeassistant.helpers.config_validation as cv
import homeassistant.util.dt as dt_util
import homeassistant.util.uuid as uuid_util
import voluptuous as vol
from homeassistant.const import EVENT_HOMEASSISTANT_STOP
from homeassistant.core import Context
from homeassistant.exceptions import HomeAssistantError
from homeassistant.helpers.json import ExtendedJSONEncoder
from homeassistant.helpers.storage import Store
from homeassistant.helpers.trace import (
    TraceElement,
    script_execution_get,
    trace_id_get,
    trace_id_set,
    trace_set_child_id,
)

from . import websocket_api
from .const import (
    CONF_STORED_TRACES,
    DATA_TRACE,
    DATA_TRACE_STORE,
    DATA_TRACES_RESTORED,
    DEFAULT_STORED_TRACES,
)
from .utils import LimitedSizeDict

"""Support for script and automation tracing and debugging."""
_LOGGER = ...
DOMAIN = ...
STORAGE_KEY = ...
STORAGE_VERSION = ...
TRACE_CONFIG_SCHEMA = ...

async def async_setup(hass, config):  # -> Literal[True]:
    """Initialize the trace integration."""
    ...

async def async_get_trace(hass, key, run_id):
    """Return the requested trace."""
    ...

async def async_list_contexts(hass, key):  # -> dict[Unknown, dict[Unknown, Unknown]]:
    """List contexts for which we have traces."""
    ...

async def async_list_traces(hass, wanted_domain, wanted_key):  # -> list[Unknown]:
    """List traces for a domain."""
    ...

def async_store_trace(hass, trace, stored_traces):  # -> None:
    """Store a trace if its key is valid."""
    ...

async def async_restore_traces(hass):  # -> None:
    """Restore saved traces."""
    ...

class BaseTrace(abc.ABC):
    """Base container for a script or automation trace."""

    context: Context
    key: str
    def as_dict(self) -> dict[str, Any]:
        """Return an dictionary version of this ActionTrace for saving."""
        ...
    @abc.abstractmethod
    def as_extended_dict(self) -> dict[str, Any]:
        """Return an extended dictionary version of this ActionTrace."""
        ...
    @abc.abstractmethod
    def as_short_dict(self) -> dict[str, Any]:
        """Return a brief dictionary version of this ActionTrace."""
        ...

class ActionTrace(BaseTrace):
    """Base container for a script or automation trace."""

    _domain: str | None = ...
    def __init__(
        self,
        item_id: str,
        config: dict[str, Any],
        blueprint_inputs: dict[str, Any],
        context: Context,
    ) -> None:
        """Container for script trace."""
        ...
    def set_trace(self, trace: dict[str, deque[TraceElement]]) -> None:
        """Set action trace."""
        ...
    def set_error(self, ex: Exception) -> None:
        """Set error."""
        ...
    def finished(self) -> None:
        """Set finish time."""
        ...
    def as_extended_dict(self) -> dict[str, Any]:
        """Return an extended dictionary version of this ActionTrace."""
        ...
    def as_short_dict(self) -> dict[str, Any]:
        """Return a brief dictionary version of this ActionTrace."""
        ...

class RestoredTrace(BaseTrace):
    """Container for a restored script or automation trace."""

    def __init__(self, data: dict[str, Any]) -> None:
        """Restore from dict."""
        ...
    def as_extended_dict(self) -> dict[str, Any]:
        """Return an extended dictionary version of this RestoredTrace."""
        ...
    def as_short_dict(self) -> dict[str, Any]:
        """Return a brief dictionary version of this RestoredTrace."""
        ...
