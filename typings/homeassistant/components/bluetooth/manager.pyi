"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Iterable
from typing import Any, Final, TYPE_CHECKING
from bleak.backends.scanner import AdvertisementDataCallback
from bleak_retry_connector import BleakSlotManager
from bluetooth_adapters import AdapterDetails, BluetoothAdapters
from homeassistant.core import (
    CALLBACK_TYPE,
    Event,
    HomeAssistant,
    callback as hass_callback,
)
from .base_scanner import BaseHaScanner, BluetoothScannerDevice
from .match import BluetoothCallbackMatcher, IntegrationMatcher
from .models import BluetoothCallback, BluetoothServiceInfoBleak
from .storage import BluetoothStorage
from bleak.backends.device import BLEDevice

"""The bluetooth integration."""
if TYPE_CHECKING: ...
FILTER_UUIDS: Final = ...
APPLE_MFR_ID: Final = ...
APPLE_IBEACON_START_BYTE: Final = ...
APPLE_HOMEKIT_START_BYTE: Final = ...
APPLE_DEVICE_ID_START_BYTE: Final = ...
APPLE_HOMEKIT_NOTIFY_START_BYTE: Final = ...
APPLE_START_BYTES_WANTED: Final = ...
MONOTONIC_TIME: Final = ...
_LOGGER = ...

class BluetoothManager:
    """Manage Bluetooth."""

    __slots__ = ...
    def __init__(
        self,
        hass: HomeAssistant,
        integration_matcher: IntegrationMatcher,
        bluetooth_adapters: BluetoothAdapters,
        storage: BluetoothStorage,
        slot_manager: BleakSlotManager,
    ) -> None:
        """Init bluetooth manager."""
        ...

    @property
    def supports_passive_scan(self) -> bool:
        """Return if passive scan is supported."""
        ...

    def async_scanner_count(self, connectable: bool = ...) -> int:
        """Return the number of scanners."""
        ...

    async def async_diagnostics(self) -> dict[str, Any]:
        """Diagnostics for the manager."""
        ...

    @hass_callback
    def async_scanner_by_source(self, source: str) -> BaseHaScanner | None:
        """Return the scanner for a source."""
        ...

    async def async_get_bluetooth_adapters(
        self, cached: bool = ...
    ) -> dict[str, AdapterDetails]:
        """Get bluetooth adapters."""
        ...

    async def async_get_adapter_from_address(self, address: str) -> str | None:
        """Get adapter from address."""
        ...

    async def async_setup(self) -> None:
        """Set up the bluetooth manager."""
        ...

    @hass_callback
    def async_stop(self, event: Event) -> None:
        """Stop the Bluetooth integration at shutdown."""
        ...

    @hass_callback
    def async_scanner_devices_by_address(
        self, address: str, connectable: bool
    ) -> list[BluetoothScannerDevice]:
        """Get BluetoothScannerDevice by address."""
        ...

    @hass_callback
    def async_discovered_devices(self, connectable: bool) -> list[BLEDevice]:
        """Return all of combined best path to discovered from all the scanners."""
        ...

    @hass_callback
    def async_setup_unavailable_tracking(self) -> None:
        """Set up the unavailable tracking."""
        ...

    @hass_callback
    def scanner_adv_received(self, service_info: BluetoothServiceInfoBleak) -> None:
        """Handle a new advertisement from any scanner.

        Callbacks from all the scanners arrive here.
        """
        ...

    @hass_callback
    def async_track_unavailable(
        self,
        callback: Callable[[BluetoothServiceInfoBleak], None],
        address: str,
        connectable: bool,
    ) -> Callable[[], None]:
        """Register a callback."""
        ...

    @hass_callback
    def async_register_callback(
        self, callback: BluetoothCallback, matcher: BluetoothCallbackMatcher | None
    ) -> Callable[[], None]:
        """Register a callback."""
        ...

    @hass_callback
    def async_ble_device_from_address(
        self, address: str, connectable: bool
    ) -> BLEDevice | None:
        """Return the BLEDevice if present."""
        ...

    @hass_callback
    def async_address_present(self, address: str, connectable: bool) -> bool:
        """Return if the address is present."""
        ...

    @hass_callback
    def async_discovered_service_info(
        self, connectable: bool
    ) -> Iterable[BluetoothServiceInfoBleak]:
        """Return all the discovered services info."""
        ...

    @hass_callback
    def async_last_service_info(
        self, address: str, connectable: bool
    ) -> BluetoothServiceInfoBleak | None:
        """Return the last service info for an address."""
        ...

    @hass_callback
    def async_rediscover_address(self, address: str) -> None:
        """Trigger discovery of devices which have already been seen."""
        ...

    def async_register_scanner(
        self,
        scanner: BaseHaScanner,
        connectable: bool,
        connection_slots: int | None = ...,
    ) -> CALLBACK_TYPE:
        """Register a new scanner."""
        ...

    @hass_callback
    def async_register_bleak_callback(
        self, callback: AdvertisementDataCallback, filters: dict[str, set[str]]
    ) -> CALLBACK_TYPE:
        """Register a callback."""
        ...

    @hass_callback
    def async_release_connection_slot(self, device: BLEDevice) -> None:
        """Release a connection slot."""
        ...

    @hass_callback
    def async_allocate_connection_slot(self, device: BLEDevice) -> bool:
        """Allocate a connection slot."""
        ...

    @hass_callback
    def async_get_learned_advertising_interval(self, address: str) -> float | None:
        """Get the learned advertising interval for a MAC address."""
        ...

    @hass_callback
    def async_get_fallback_availability_interval(self, address: str) -> float | None:
        """Get the fallback availability timeout for a MAC address."""
        ...

    @hass_callback
    def async_set_fallback_availability_interval(
        self, address: str, interval: float
    ) -> None:
        """Override the fallback availability timeout for a MAC address."""
        ...
