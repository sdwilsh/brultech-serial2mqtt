"""
This type stub file was generated by pyright.
"""

import asyncio
import datetime
import enum
from collections.abc import Awaitable, Iterable, Mapping
from typing import TYPE_CHECKING, Any, Callable

import attr
import voluptuous as vol
from homeassistant.auth import AuthManager
from homeassistant.components.http import HomeAssistantHTTP
from homeassistant.config_entries import ConfigEntries

"""
Core components of Home Assistant.

Home Assistant is a Home Automation framework for observing the state
of entities and react to changes.
"""
if TYPE_CHECKING: ...
STAGE_1_SHUTDOWN_TIMEOUT = ...
STAGE_2_SHUTDOWN_TIMEOUT = ...
STAGE_3_SHUTDOWN_TIMEOUT = ...
T = ...
_UNDEF: dict = ...
CALLABLE_T = ...
CALLBACK_TYPE = Callable[[], None]
CORE_STORAGE_KEY = ...
CORE_STORAGE_VERSION = ...
DOMAIN = ...
BLOCK_LOG_TIMEOUT = ...
SERVICE_CALL_LIMIT = ...
SOURCE_DISCOVERED = ...
SOURCE_STORAGE = ...
SOURCE_YAML = ...
TIMEOUT_EVENT_START = ...
_LOGGER = ...

def split_entity_id(entity_id: str) -> list[str]:
    """Split a state entity ID into domain and object ID."""
    ...

VALID_ENTITY_ID = ...

def valid_entity_id(entity_id: str) -> bool:
    """Test if an entity ID is a valid format.

    Format: <domain>.<entity> where both are slugs.
    """
    ...

def valid_state(state: str) -> bool:
    """Test if a state is valid."""
    ...

def callback(func: CALLABLE_T) -> CALLABLE_T:
    """Annotation to mark method as safe to call from within the event loop."""
    ...

def is_callback(func: Callable[..., Any]) -> bool:
    """Check if function is safe to be called in the event loop."""
    ...

@enum.unique
class HassJobType(enum.Enum):
    """Represent a job type."""

    Coroutinefunction = ...
    Callback = ...
    Executor = ...

class HassJob:
    """Represent a job to be run later.

    We check the callable type in advance
    so we can avoid checking it every time
    we run the job.
    """

    __slots__ = ...
    def __init__(self, target: Callable) -> None:
        """Create a job object."""
        ...
    def __repr__(self) -> str:
        """Return the job."""
        ...

class CoreState(enum.Enum):
    """Represent the current state of Home Assistant."""

    not_running = ...
    starting = ...
    running = ...
    stopping = ...
    final_write = ...
    stopped = ...
    def __str__(self) -> str:
        """Return the event."""
        ...

class HomeAssistant:
    """Root object of the Home Assistant home automation."""

    auth: AuthManager
    http: HomeAssistantHTTP = ...
    config_entries: ConfigEntries = ...
    def __init__(self) -> None:
        """Initialize new Home Assistant object."""
        ...
    @property
    def is_running(self) -> bool:
        """Return if Home Assistant is running."""
        ...
    @property
    def is_stopping(self) -> bool:
        """Return if Home Assistant is stopping."""
        ...
    def start(self) -> int:
        """Start Home Assistant.

        Note: This function is only used for testing.
        For regular use, use "await hass.run()".
        """
        ...
    async def async_run(self, *, attach_signals: bool = ...) -> int:
        """Home Assistant main entry point.

        Start Home Assistant and block until stopped.

        This method is a coroutine.
        """
        ...
    async def async_start(self) -> None:
        """Finalize startup from inside the event loop.

        This method is a coroutine.
        """
        ...
    def add_job(self, target: Callable[..., Any], *args: Any) -> None:
        """Add job to the executor pool.

        target: target to call.
        args: parameters for method to call.
        """
        ...
    @callback
    def async_add_job(
        self, target: Callable[..., Any], *args: Any
    ) -> asyncio.Future | None:
        """Add a job from within the event loop.

        This method must be run in the event loop.

        target: target to call.
        args: parameters for method to call.
        """
        ...
    @callback
    def async_add_hass_job(self, hassjob: HassJob, *args: Any) -> asyncio.Future | None:
        """Add a HassJob from within the event loop.

        This method must be run in the event loop.
        hassjob: HassJob to call.
        args: parameters for method to call.
        """
        ...
    def create_task(self, target: Awaitable) -> None:
        """Add task to the executor pool.

        target: target to call.
        """
        ...
    @callback
    def async_create_task(self, target: Awaitable) -> asyncio.Task:
        """Create a task from within the eventloop.

        This method must be run in the event loop.

        target: target to call.
        """
        ...
    @callback
    def async_add_executor_job(
        self, target: Callable[..., T], *args: Any
    ) -> Awaitable[T]:
        """Add an executor job from within the event loop."""
        ...
    @callback
    def async_track_tasks(self) -> None:
        """Track tasks so you can wait for all tasks to be done."""
        ...
    @callback
    def async_stop_track_tasks(self) -> None:
        """Stop track tasks so you can't wait for all tasks to be done."""
        ...
    @callback
    def async_run_hass_job(self, hassjob: HassJob, *args: Any) -> asyncio.Future | None:
        """Run a HassJob from within the event loop.

        This method must be run in the event loop.

        hassjob: HassJob
        args: parameters for method to call.
        """
        ...
    @callback
    def async_run_job(
        self, target: Callable[..., None | Awaitable], *args: Any
    ) -> asyncio.Future | None:
        """Run a job from within the event loop.

        This method must be run in the event loop.

        target: target to call.
        args: parameters for method to call.
        """
        ...
    def block_till_done(self) -> None:
        """Block until all pending work is done."""
        ...
    async def async_block_till_done(self) -> None:
        """Block until all pending work is done."""
        ...
    def stop(self) -> None:
        """Stop Home Assistant and shuts down all threads."""
        ...
    async def async_stop(self, exit_code: int = ..., *, force: bool = ...) -> None:
        """Stop Home Assistant and shuts down all threads.

        The "force" flag commands async_stop to proceed regardless of
        Home Assistant's current state. You should not set this flag
        unless you're testing.

        This method is a coroutine.
        """
        ...

@attr.s(slots=True, frozen=True)
class Context:
    """The context that triggered something."""

    user_id: str = ...
    parent_id: str | None = ...
    id: str = ...
    def as_dict(self) -> dict[str, str | None]:
        """Return a dictionary representation of the context."""
        ...

class EventOrigin(enum.Enum):
    """Represent the origin of an event."""

    local = ...
    remote = ...
    def __str__(self) -> str:
        """Return the event."""
        ...

class Event:
    """Representation of an event within the bus."""

    __slots__ = ...
    def __init__(
        self,
        event_type: str,
        data: dict[str, Any] | None = ...,
        origin: EventOrigin = ...,
        time_fired: datetime.datetime | None = ...,
        context: Context | None = ...,
    ) -> None:
        """Initialize a new event."""
        ...
    def __hash__(self) -> int:
        """Make hashable."""
        ...
    def as_dict(self) -> dict[str, Any]:
        """Create a dict representation of this Event.

        Async friendly.
        """
        ...
    def __repr__(self) -> str:
        """Return the representation."""
        ...
    def __eq__(self, other: Any) -> bool:
        """Return the comparison."""
        ...

class EventBus:
    """Allow the firing of and listening for events."""

    def __init__(self, hass: HomeAssistant) -> None:
        """Initialize a new event bus."""
        ...
    @callback
    def async_listeners(self) -> dict[str, int]:
        """Return dictionary with events and the number of listeners.

        This method must be run in the event loop.
        """
        ...
    @property
    def listeners(self) -> dict[str, int]:
        """Return dictionary with events and the number of listeners."""
        ...
    def fire(
        self,
        event_type: str,
        event_data: dict | None = ...,
        origin: EventOrigin = ...,
        context: Context | None = ...,
    ) -> None:
        """Fire an event."""
        ...
    @callback
    def async_fire(
        self,
        event_type: str,
        event_data: dict[str, Any] | None = ...,
        origin: EventOrigin = ...,
        context: Context | None = ...,
        time_fired: datetime.datetime | None = ...,
    ) -> None:
        """Fire an event.

        This method must be run in the event loop.
        """
        ...
    def listen(self, event_type: str, listener: Callable) -> CALLBACK_TYPE:
        """Listen for all events or events of a specific type.

        To listen to all events specify the constant ``MATCH_ALL``
        as event_type.
        """
        ...
    @callback
    def async_listen(
        self, event_type: str, listener: Callable, event_filter: Callable | None = ...
    ) -> CALLBACK_TYPE:
        """Listen for all events or events of a specific type.

        To listen to all events specify the constant ``MATCH_ALL``
        as event_type.

        An optional event_filter, which must be a callable decorated with
        @callback that returns a boolean value, determines if the
        listener callable should run.

        This method must be run in the event loop.
        """
        ...
    def listen_once(
        self, event_type: str, listener: Callable[[Event], None]
    ) -> CALLBACK_TYPE:
        """Listen once for event of a specific type.

        To listen to all events specify the constant ``MATCH_ALL``
        as event_type.

        Returns function to unsubscribe the listener.
        """
        ...
    @callback
    def async_listen_once(self, event_type: str, listener: Callable) -> CALLBACK_TYPE:
        """Listen once for event of a specific type.

        To listen to all events specify the constant ``MATCH_ALL``
        as event_type.

        Returns registered listener that can be used with remove_listener.

        This method must be run in the event loop.
        """
        ...

class State:
    """Object to represent a state within the state machine.

    entity_id: the entity that is represented.
    state: the state of the entity
    attributes: extra information on entity and state
    last_changed: last time the state was changed, not the attributes.
    last_updated: last time this object was updated.
    context: Context in which it was created
    domain: Domain of this state.
    object_id: Object id of this state.
    """

    __slots__ = ...
    def __init__(
        self,
        entity_id: str,
        state: str,
        attributes: Mapping[str, Any] | None = ...,
        last_changed: datetime.datetime | None = ...,
        last_updated: datetime.datetime | None = ...,
        context: Context | None = ...,
        validate_entity_id: bool | None = ...,
    ) -> None:
        """Initialize a new state."""
        ...
    @property
    def name(self) -> str:
        """Name of this state."""
        ...
    def as_dict(self) -> dict:
        """Return a dict representation of the State.

        Async friendly.

        To be used for JSON serialization.
        Ensures: state == State.from_dict(state.as_dict())
        """
        ...
    @classmethod
    def from_dict(cls, json_dict: dict) -> Any:
        """Initialize a state from a dict.

        Async friendly.

        Ensures: state == State.from_json_dict(state.to_json_dict())
        """
        ...
    def __eq__(self, other: Any) -> bool:
        """Return the comparison of the state."""
        ...
    def __repr__(self) -> str:
        """Return the representation of the states."""
        ...

class StateMachine:
    """Helper class that tracks the state of different entities."""

    def __init__(self, bus: EventBus, loop: asyncio.events.AbstractEventLoop) -> None:
        """Initialize state machine."""
        ...
    def entity_ids(self, domain_filter: str | None = ...) -> list[str]:
        """List of entity ids that are being tracked."""
        ...
    @callback
    def async_entity_ids(self, domain_filter: str | Iterable | None = ...) -> list[str]:
        """List of entity ids that are being tracked.

        This method must be run in the event loop.
        """
        ...
    @callback
    def async_entity_ids_count(self, domain_filter: str | Iterable | None = ...) -> int:
        """Count the entity ids that are being tracked.

        This method must be run in the event loop.
        """
        ...
    def all(self, domain_filter: str | Iterable | None = ...) -> list[State]:
        """Create a list of all states."""
        ...
    @callback
    def async_all(self, domain_filter: str | Iterable | None = ...) -> list[State]:
        """Create a list of all states matching the filter.

        This method must be run in the event loop.
        """
        ...
    def get(self, entity_id: str) -> State | None:
        """Retrieve state of entity_id or None if not found.

        Async friendly.
        """
        ...
    def is_state(self, entity_id: str, state: str) -> bool:
        """Test if entity exists and is in specified state.

        Async friendly.
        """
        ...
    def remove(self, entity_id: str) -> bool:
        """Remove the state of an entity.

        Returns boolean to indicate if an entity was removed.
        """
        ...
    @callback
    def async_remove(self, entity_id: str, context: Context | None = ...) -> bool:
        """Remove the state of an entity.

        Returns boolean to indicate if an entity was removed.

        This method must be run in the event loop.
        """
        ...
    def set(
        self,
        entity_id: str,
        new_state: str,
        attributes: Mapping[str, Any] | None = ...,
        force_update: bool = ...,
        context: Context | None = ...,
    ) -> None:
        """Set the state of an entity, add entity if it does not exist.

        Attributes is an optional dict to specify attributes of this state.

        If you just update the attributes and not the state, last changed will
        not be affected.
        """
        ...
    @callback
    def async_reserve(self, entity_id: str) -> None:
        """Reserve a state in the state machine for an entity being added.

        This must not fire an event when the state is reserved.

        This avoids a race condition where multiple entities with the same
        entity_id are added.
        """
        ...
    @callback
    def async_available(self, entity_id: str) -> bool:
        """Check to see if an entity_id is available to be used."""
        ...
    @callback
    def async_set(
        self,
        entity_id: str,
        new_state: str,
        attributes: Mapping[str, Any] | None = ...,
        force_update: bool = ...,
        context: Context | None = ...,
    ) -> None:
        """Set the state of an entity, add entity if it does not exist.

        Attributes is an optional dict to specify attributes of this state.

        If you just update the attributes and not the state, last changed will
        not be affected.

        This method must be run in the event loop.
        """
        ...

class Service:
    """Representation of a callable service."""

    __slots__ = ...
    def __init__(
        self, func: Callable, schema: vol.Schema | None, context: Context | None = ...
    ) -> None:
        """Initialize a service."""
        ...

class ServiceCall:
    """Representation of a call to a service."""

    __slots__ = ...
    def __init__(
        self,
        domain: str,
        service: str,
        data: dict | None = ...,
        context: Context | None = ...,
    ) -> None:
        """Initialize a service call."""
        ...
    def __repr__(self) -> str:
        """Return the representation of the service."""
        ...

class ServiceRegistry:
    """Offer the services over the eventbus."""

    def __init__(self, hass: HomeAssistant) -> None:
        """Initialize a service registry."""
        ...
    @property
    def services(self) -> dict[str, dict[str, Service]]:
        """Return dictionary with per domain a list of available services."""
        ...
    @callback
    def async_services(self) -> dict[str, dict[str, Service]]:
        """Return dictionary with per domain a list of available services.

        This method must be run in the event loop.
        """
        ...
    def has_service(self, domain: str, service: str) -> bool:
        """Test if specified service exists.

        Async friendly.
        """
        ...
    def register(
        self,
        domain: str,
        service: str,
        service_func: Callable,
        schema: vol.Schema | None = ...,
    ) -> None:
        """
        Register a service.

        Schema is called to coerce and validate the service data.
        """
        ...
    @callback
    def async_register(
        self,
        domain: str,
        service: str,
        service_func: Callable,
        schema: vol.Schema | None = ...,
    ) -> None:
        """
        Register a service.

        Schema is called to coerce and validate the service data.

        This method must be run in the event loop.
        """
        ...
    def remove(self, domain: str, service: str) -> None:
        """Remove a registered service from service handler."""
        ...
    @callback
    def async_remove(self, domain: str, service: str) -> None:
        """Remove a registered service from service handler.

        This method must be run in the event loop.
        """
        ...
    def call(
        self,
        domain: str,
        service: str,
        service_data: dict | None = ...,
        blocking: bool = ...,
        context: Context | None = ...,
        limit: float | None = ...,
        target: dict | None = ...,
    ) -> bool | None:
        """
        Call a service.

        See description of async_call for details.
        """
        ...
    async def async_call(
        self,
        domain: str,
        service: str,
        service_data: dict | None = ...,
        blocking: bool = ...,
        context: Context | None = ...,
        limit: float | None = ...,
        target: dict | None = ...,
    ) -> bool | None:
        """
        Call a service.

        Specify blocking=True to wait until service is executed.
        Waits a maximum of limit, which may be None for no timeout.

        If blocking = True, will return boolean if service executed
        successfully within limit.

        This method will fire an event to indicate the service has been called.

        Because the service is sent as an event you are not allowed to use
        the keys ATTR_DOMAIN and ATTR_SERVICE in your service_data.

        This method is a coroutine.
        """
        ...

class Config:
    """Configuration settings for Home Assistant."""

    def __init__(self, hass: HomeAssistant) -> None:
        """Initialize a new config object."""
        ...
    def distance(self, lat: float, lon: float) -> float | None:
        """Calculate distance from Home Assistant.

        Async friendly.
        """
        ...
    def path(self, *path: str) -> str:
        """Generate path to the file within the configuration directory.

        Async friendly.
        """
        ...
    def is_allowed_external_url(self, url: str) -> bool:
        """Check if an external URL is allowed."""
        ...
    def is_allowed_path(self, path: str) -> bool:
        """Check if the path is valid for access from outside."""
        ...
    def as_dict(self) -> dict:
        """Create a dictionary representation of the configuration.

        Async friendly.
        """
        ...
    def set_time_zone(self, time_zone_str: str) -> None:
        """Help to set the time zone."""
        ...
    async def async_update(self, **kwargs: Any) -> None:
        """Update the configuration from a dictionary."""
        ...
    async def async_load(self) -> None:
        """Load [homeassistant] core config."""
        ...
    async def async_store(self) -> None:
        """Store [homeassistant] core config."""
        ...
